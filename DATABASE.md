<details>
  <summary><h3>1. Key?</h3></summary>
  <ul>
    <li> 데이터베이스에서 키(Key)는 데이터를 구분하고, 조회하고, 관계를 설정하는 데 사용되는 필드(또는 필드의 집합)를 말합니다. 주요한 키의 종류에는 다음과 같은 것들이 있습니다. </li>
    <ul>
      <li> 슈퍼키(Super Key): 행을 고유하게 식별하는 하나 이상의 속성(열)의 집합입니다. 즉, 모든 행에 대해 유일성을 보장합니다. </li>
      <li> 후보키(Candidate Key): 슈퍼키 중에서 최소성을 만족하는 키를 말합니다. 최소성이란 필요 이상의 속성을 갖지 않는, 즉 속성을 줄여도 유일성이 유지되는 키를 의미합니다. </li>
      <li> 기본키(Primary Key): 후보키 중에서 선택된 메인 키입니다. 이 키는 테이블 내에서 데이터의 고유성과 일관성을 보장합니다. NULL 값을 허용하지 않으며, 중복 값을 가질 수 없습니다. </li>
      <li> 대체키(Alternate Key): 기본키로 선택되지 않은 후보키를 말합니다. </li>
      <li> 외래키(Foreign Key): 다른 테이블의 기본키를 참조하는 키입니다. 이를 통해 테이블 간의 관계를 설정합니다. </li>
    </ul>
    <li> 기본키는 일반적으로 수정이 불가능합니다. 한 번 테이블에 데이터가 입력되면, 그 행의 기본키는 변경되지 않습니다. 이는 데이터의 일관성과 정확성을 보장하기 위한 제약입니다. </li>
    <li> MySQL에서는 기본키를 설정하지 않아도 테이블을 생성할 수 있습니다. 이는 모든 행이 고유하지 않아도 될 수 있기 때문입니다. 하지만, 기본키가 없는 테이블에서는 데이터의 수정, 삭제, 조회 등의 작업이 비효율적일 수 있습니다. </li>
    <li> 외래키는 NULL 값을 가질 수 있습니다. 이는 외래키가 참조하는 테이블의 특정 행을 참조하지 않는다는 것을 의미합니다. </li>
    <li> UNIQUE 키워드가 붙은 칼럼을 사용한 쿼리는 그렇지 않은 것과 비교하여 일반적으로 더 빠른 성능을 보입니다. 이는 UNIQUE 제약 조건이 인덱스를 생성하므로, 데이터베이스 관리 시스템(DBMS)이 데이터를 더 효율적으로 조회할 수 있기 때문입니다. 하지만, 데이터의 삽입, 수정, 삭제 등의 작업은 인덱스를 유지하기 위한 추가 작업이 필요하므로, 이러한 작업의 성능은 저하될 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary><h3>2. Join?</h3></summary>
  <ul>
    <li> 데이터베이스에서 조인(Join)은 두 개 이상의 테이블에서 데이터를 결합하는 방법입니다. 주로 공통의 필드를 기준으로 데이터를 연결합니다. 조인의 종류는 다음과 같습니다. </li>
    <ul>
      <li> 내부 조인(Inner Join): 두 테이블에서 조건에 일치하는 행만 반환합니다. </li>
      <li> 외부 조인(Outer Join): 하나의 테이블은 전체를, 다른 테이블은 일치하는 행만 반환합니다. 외부 조인에는 왼쪽 외부 조인(Left Outer Join), 오른쪽 외부 조인(Right Outer Join), 전체 외부 조인(Full Outer Join)이 있습니다. </li>
      <li> 자연 조인(Natural Join): 두 테이블에서 이름과 자료형이 같은 모든 칼럼에 대해 내부 조인을 수행합니다. </li>
      <li> 크로스 조인(Cross Join): 두 테이블의 모든 행을 결합합니다. </li>
    </ul>
    <li> 조인 연산은 데이터의 양에 따라 시간이 많이 걸릴 수 있기 때문에, 데이터베이스 관리 시스템(DBMS)는 다양한 구현 방식을 사용합니다. 예를 들어, 중첩 루프 조인(Nested Loops Join), 해시 조인(Hash Join), 병합 조인(Merge Join) 등이 있습니다. 이들 방식은 서로 다른 특징과 성능을 가지므로, DBMS는 쿼리와 데이터의 특성에 따라 최적의 방식을 선택합니다. </li>
    <li> 쿼리에서 어떤 조인 구현 방식을 사용하는지를 알기 위해서는 실행 계획(Execution Plan)을 확인해야 합니다. 대부분의 DBMS는 쿼리의 실행 계획을 확인할 수 있는 도구를 제공합니다. 실행 계획에는 쿼리가 어떻게 실행될지, 어떤 인덱스가 사용될지, 어떤 조인 방식이 사용될지 등의 정보가 포함되어 있습니다. </li>
    <li> 조인의 성능은 인덱스의 유무에 크게 영향을 받습니다. 인덱스가 있는 칼럼을 기준으로 조인을 수행하면, DBMS는 인덱스를 활용하여 데이터를 빠르게 조회하고 조인을 수행할 수 있습니다. 반면, 인덱스가 없는 칼럼을 기준으로 조인을 수행하면, 모든 데이터를 대상으로 조인을 수행해야 하므로 성능이 저하될 수 있습니다. 따라서, 조인의 성능을 최적화하기 위해서는 조인에 사용되는 칼럼에 적절한 인덱스를 생성하는 것이 중요합니다. </li>
  </ul>
</details>

<details>
  <summary><h3>3. 인덱스?</h3></summary>
  <ul>
    <li> 인덱스는 데이터베이스에서 데이터를 효율적으로 검색하고 접근하기 위한 구조입니다. 책의 찾아보기와 비슷하게, 데이터베이스에서도 특정 데이터를 찾기 위해 인덱스를 사용합니다. 인덱스를 사용하면 테이블의 모든 데이터를 검색하지 않고도 원하는 데이터를 빠르게 찾을 수 있습니다. </li>
    <li> 하지만 인덱스는 데이터의 삽입, 수정, 삭제 등의 작업이 빈번하게 일어나는 테이블에서는 성능이 저하될 수 있습니다. 이는 인덱스를 유지하고 업데이트하기 위한 추가적인 작업이 필요하기 때문입니다. 따라서, 데이터의 변경이 자주 일어나는 테이블에서는 인덱스의 사용을 신중하게 고려해야 합니다. </li>
    <li> 인덱스에서 사용하지 않겠다고 선택한 값은 인덱스 정책을 따르지 않습니다. 즉, 해당 값에 대한 검색은 테이블의 전체 데이터를 대상으로 수행되며, 이는 성능에 영향을 줄 수 있습니다. </li>
    <li> ORDER BY나 GROUP BY 연산은 결과 집합을 특정 칼럼의 값에 따라 정렬하거나 그룹화하는 역할을 합니다. 이때 해당 칼럼에 인덱스가 있다면, 데이터베이스 관리 시스템(DBMS)은 인덱스를 사용하여 효율적으로 연산을 수행할 수 있습니다. 인덱스가 없다면, DBMS는 모든 데이터를 메모리에 로드하고 정렬 또는 그룹화를 수행해야 하므로 처리 시간이 더 오래 걸릴 수 있습니다. </li>
    <li> 기본키는 테이블의 각 행을 고유하게 식별하는 역할을 합니다. 기본키는 인덱스의 한 형태라고 볼 수 있습니다. 이는 기본키가 자동으로 인덱스로 작용하며, 데이터의 검색과 접근을 빠르게 하기 때문입니다. 하지만 인덱스와 기본키는 역할과 제약에서 차이가 있습니다. 예를 들어, 기본키는 NULL 값을 허용하지 않으며, 테이블에 하나만 존재할 수 있습니다. </li>
    <li> 외래키 역시 인덱스로 사용될 수 있습니다. 외래키에 인덱스를 생성하면, 해당 외래키를 사용하는 조인 연산의 성능이 향상될 수 있습니다. 하지만 외래키는 다른 테이블의 기본키를 참조하는 역할을 하므로, 인덱스와는 다른 성질과 제약을 가집니다. 예를 들어, 외래키 값은 참조하는 테이블의 기본키 값 중 하나이거나 NULL이어야 합니다. </li>
  </ul>
</details>

<details>
  <summary><h3>3-1. B-Tree와 B+Tree?</h3></summary>
  <ul>
    <li> B-Tree는 균형 이진 트리의 일반화된 형태로, 각 노드가 가질 수 있는 자식 노드의 수가 두 개 이상인 트리를 말합니다. B-Tree의 특징은 모든 잎 노드가 같은 깊이를 가지며, 모든 내부 노드는 일정 범위의 자식 노드를 가진다는 것입니다. </li>
    <li> B+Tree는 B-Tree의 변형 형태로, 모든 값이 잎 노드에만 저장되고, 내부 노드는 키값과 포인터만을 가집니다. 이로 인해 B+Tree는 B-Tree에 비해 더 많은 값들을 저장할 수 있습니다. </li>
    <li> B+Tree가 B-Tree보다 항상 좋은 것은 아닙니다. B+Tree는 모든 값들이 잎 노드에 저장되므로, 특정 값에 대한 검색 시에는 B-Tree에 비해 더 많은 디스크 I/O가 필요할 수 있습니다. 또한, B+Tree는 B-Tree에 비해 구조가 복잡하므로, 구현 및 유지 관리가 어렵습니다. </li>
    <li> RBT(Red-Black Tree)는 메모리 내에서 빠른 검색 성능을 제공하지만, 디스크 기반의 저장소에서는 B-Tree나 B+Tree가 더 효율적입니다. B-Tree와 B+Tree는 노드당 키의 수가 많아 디스크 I/O 작업을 최소화하는 데 유리하며, 디스크 페이지 크기와 잘 맞는 구조를 가지고 있습니다. </li>
    <li> B-Tree/B+Tree에서 오름차순으로 정렬된 인덱스를 내림차순으로 조회하는 경우 성능에 큰 차이는 없습니다. B-Tree/B+Tree는 각 노드에 여러 키를 저장하므로, 오름차순 또는 내림차순으로 트리를 탐색하는 데 드는 비용은 거의 동일하기 때문입니다. 하지만 실제 성능은 트리의 높이, 디스크 I/O 비용, 페이지 교체 알고리즘 등 여러 요인에 의해 영향을 받을 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary><h3>4. 트랜잭션?</h3></summary>
  <ul>
    <li> 트랜잭션은 데이터베이스에서 한 번에 수행되어야 하는 작업의 단위를 의미합니다. 예를 들어, 은행 계좌에서 돈을 이체하는 경우, 한 계좌에서 돈을 빼는 작업과 다른 계좌에 돈을 넣는 작업이 모두 성공하거나, 둘 다 실패해야 합니다. 이런 작업들을 하나의 트랜잭션으로 묶을 수 있습니다. </li>
    <li> 트랜잭션은 ACID 원칙을 따릅니다. ACID는 Atomicity(원자성), Consistency(일관성), Isolation(고립성), Durability(영속성)의 약자입니다. </li>
    <ul>
      <li> 원자성: 트랜잭션이 DB에 모두 반영되거나, 아무것도 반영되지 않아야 함을 의미합니다. 즉, 트랜잭션 내의 모든 작업이 성공하거나, 하나라도 실패하면 모든 작업이 취소됩니다. </li>
      <li> 일관성: 트랜잭션이 성공적으로 완료되면, DB가 일관된 상태를 유지해야 함을 의미합니다. 즉, 트랜잭션 시작 전과 후의 DB 상태는 일관성을 유지해야 합니다. </li>
      <li> 고립성: 동시에 실행되는 트랜잭션이 서로 영향을 미치지 않아야 함을 의미합니다. 즉, 하나의 트랜잭션이 완료될 때까지, 다른 트랜잭션에서는 그 결과를 볼 수 없습니다. </li>
      <li> 영속성: 트랜잭션이 성공적으로 완료되면, 그 결과는 영구적으로 DB에 저장되어야 함을 의미합니다. 즉, 시스템 장애가 발생하더라도, 완료된 트랜잭션의 결과는 보존되어야 합니다. </li>
    </ul>
    <li> Durability를 보장하기 위해서는 DBMS는 트랜잭션의 로그를 디스크와 같은 영구적인 저장 매체에 기록해야 합니다. 이를 통해 시스템 장애가 발생하더라도, 로그를 이용하여 트랜잭션을 복구할 수 있습니다. </li>
    <li> 트랜잭션은 주로 금융, 예약, 주문 등과 같이 데이터의 일관성과 정확성이 중요한 작업에서 사용됩니다. 예를 들어, 웹 사이트에서 상품을 주문하고 결제하는 경우, 주문 정보를 생성하고, 재고를 줄이고, 결제를 처리하는 작업을 하나의 트랜잭션으로 묶을 수 있습니다. </li>
    <li> 읽기 작업에서도 트랜잭션을 사용할 수 있습니다. 특히, 여러 테이블에서 데이터를 읽어서 일관된 결과를 얻어야 하는 경우에는 트랜잭션을 사용해야 합니다. 이는 다른 트랜잭션이 동시에 데이터를 변경하는 것을 방지하므로, 데이터의 일관성을 보장할 수 있습니다. 하지만, 모든 읽기 작업에 트랜잭션을 사용하는 것은 오버헤드를 증가시킬 수 있으므로, 실제 상황에 따라 적절하게 사용해야 합니다. </li>
  </ul>
</details>

<details>
  <summary><h3>4-1. 트랜잭션 격리 레벨?</h3></summary>
  <ul>
    <li> 트랜잭션 격리 레벨(Transaction Isolation Level)은 동시에 여러 트랜잭션이 실행될 때, 트랜잭션들이 서로 얼마나 영향을 미치는지를 결정하는 방법입니다. SQL 표준에서는 4가지 격리 레벨을 정의하고 있습니다. </li>
    <ul>
      <li> READ UNCOMMITTED: 가장 낮은 격리 레벨로, 한 트랜잭션에서 변경한 데이터를 다른 트랜잭션이 아직 커밋되지 않은 상태에서 읽을 수 있습니다. 이로 인해 'Dirty Read'와 같은 문제가 발생할 수 있습니다. </li>
      <li> READ COMMITTED: 한 트랜잭션에서 변경한 데이터는 해당 트랜잭션이 커밋한 이후에만 다른 트랜잭션에서 읽을 수 있습니다. 이렇게 하면 'Dirty Read' 문제는 해결되지만, 한 트랜잭션에서 같은 데이터를 여러 번 읽을 때 일관성 없는 결과를 볼 수 있는 'Non-Repeatable Read' 문제가 발생할 수 있습니다. </li>
      <li> REPEATABLE READ: 한 트랜잭션에서 데이터를 읽은 이후에는, 다른 트랜잭션에서 그 데이터를 변경할 수 없습니다. 이렇게 하면 'Non-Repeatable Read' 문제는 해결되지만, 한 트랜잭션에서 쿼리의 결과가 다른 트랜잭션에 의해 변경되는 'Phantom Read' 문제가 발생할 수 있습니다. </li>
      <li> SERIALIZABLE: 가장 높은 격리 레벨로, 트랜잭션들이 순차적으로 실행되도록 합니다. 이렇게 하면 'Phantom Read' 문제도 해결할 수 있지만, 성능에 큰 영향을 줄 수 있습니다. </li>
    </ul>
    <li> 모든 DBMS가 이 4가지 격리 레벨을 모두 구현하고 있는 것은 아닙니다. 이는 각 DBMS의 내부 구조와 성능, 일관성 등의 요구사항에 따라 다르기 때문입니다. 예를 들어, Oracle은 READ COMMITTED와 SERIALIZABLE만을 지원하고, MySQL(InnoDB)은 REPEATABLE READ를 기본 격리 레벨로 사용합니다. </li>
    <li> MySQL의 InnoDB 스토리지 엔진에서는, Undo 영역과 Redo 영역을 통해 트랜잭션의 일관성과 복구를 관리합니다. Undo 영역은 트랜잭션이 변경한 데이터의 이전 버전을 저장하여, 트랜잭션의 롤백이나 MVCC(Multi-Version Concurrency Control)를 지원합니다. 반면, Redo 영역은 트랜잭션이 변경한 데이터의 새로운 버전을 로깅하여, 시스템 장애 발생 시 트랜잭션의 복구를 지원합니다. </li>
    <li> 스토리지 엔진은 DBMS에서 데이터의 저장 방식과 접근 방식을 결정하는 구성 요소입니다. 스토리지 엔진은 데이터의 저장 구조, 인덱싱, 트랜잭션 처리, 복구 등을 담당하며, DBMS의 성능과 기능에 큰 영향을 미칩니다. 예를 들어, MySQL에서는 InnoDB와 MyISAM 등 다양한 스토리지 엔진을 제공하며, 사용자는 데이터의 특성에 따라 적절한 스토리지 엔진을 선택할 수 있습니다. </li>
  </ul>
</details>
