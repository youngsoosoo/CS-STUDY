<details>
  <summary><h3> 1. 링크드 리스트 </h3></summary>
  <ul>
    <li> 링크드 리스트(Linked List)는 데이터와 다음 노드를 가리키는 포인터로 이루어진 노드들이 연결된 선형 자료구조입니다. 링크드 리스트는 단일(Singly) 또는 양방향(Doubly)으로 연결될 수 있으며, 마지막 노드가 첫 번째 노드를 가리키면 원형(Circular) 링크드 리스트라고 합니다.</li>
    <li> 링크드 리스트와 배열을 비교하면 다음과 같습니다.</li>
    <ul>
      <li> 메모리 구조: 배열은 연속된 메모리 공간에 데이터를 저장하며, 링크드 리스트는 불연속적인 메모리 공간에 데이터를 저장합니다. </li>
      <li> 메모리 효율성: 배열은 고정된 크기를 가지므로 메모리를 미리 할당해야 하지만, 링크드 리스트는 필요할 때마다 메모리를 할당(동적 할당)하므로 더 효율적입니다. </li>
      <li> 삽입/삭제 연산: 배열에서 중간에 데이터를 삽입하거나 삭제하려면 연속성을 유지하기 위해 다른 데이터를 이동시켜야 하므로 비효율적입니다. 반면, 링크드 리스트에서는 단지 포인터를 변경하면 되므로 효율적입니다. </li>
      <li> 접근 속도: 배열은 인덱스를 통해 빠르게 접근할 수 있지만(랜덤 접근), 링크드 리스트는 선형적으로 탐색해야 하므로 접근 속도가 느립니다. </li>
    </ul>
    <li> 링크드 리스트를 기반으로 구현할 수 있는 다른 자료구조는 다음과 같습니다. </li>
    <ul>
      <li> 스택(Stack): 링크드 리스트의 한 쪽 끝에서 데이터를 삽입하거나 삭제하여 스택을 구현할 수 있습니다. </li>
      <li> 큐(Queue): 링크드 리스트의 한 쪽 끝에서 데이터를 삽입하고, 반대 쪽 끝에서 데이터를 삭제하여 큐를 구현할 있습니다. </li>
      <li> 덱(Deque): 양방향 링크드 리스트를 사용하여 양쪽 끝에서 데이터를 삽입하거나 삭제할 수 있어 덱을 구현할 수 있습니다. </li>
    </ul>
  </ul>
</details>

<details>
  <summary><h3> 2. 스택과 큐 </h3></summary>
  <ul>
    <li> 스택(Stack)은 LIFO(Last In First Out) 원칙에 따라 데이터를 저장하는 선형 자료구조입니다. 가장 마지막에 삽입된 데이터가 가장 먼저 나오는 구조를 가집니다. 주요 연산으로는 데이터를 삽입하는 push, 가장 최근에 삽입된 데이터를 제거하는 pop, 가장 최근에 삽입된 데이터를 반환하는 top 등이 있습니다. </li>
    <li> 큐(Queue)는 FIFO(First In First Out) 원칙에 따라 데이터를 저장하는 선형 자료구조입니다. 가장 먼저 삽입된 데이터가 가장 먼저 나오는 구조를 가집니다. 주요 연산으로는 데이터를 삽입하는 enqueue, 가장 먼저 삽입된 데이터를 제거하는 dequeue, 가장 먼저 삽입된 데이터를 반환하는 front 등이 있습니다. </li>
    <li> 스택 2개를 이용하여 큐를 구현하는 방법은 다음과 같습니다. </li>
    <ul>
      <li> 데이터를 삽입할 때는 첫 번째 스택에 push합니다. </li>
      <li> 데이터를 제거할 때는 두 번째 스택을 확인합니다. 두 번째 스택이 비어있으면, 첫 번째 스택의 모든 요소를 pop해서 두 번째 스택에 push한 후, 두 번째 스택에서 pop합니다. 두 번째 스택이 비어있지 않으면, 두 번째 스택에서 바로 pop합니다. 이 방법의 시간 복잡도는 데이터 삽입이 O(1), 데이터 제거가 최악의 경우 O(n)입니다 </li>
    </ul>
    <li> 큐 2개를 이용하여 스택을 구현하는 방법은 다음과 같습니다. </li>
    <ul>
      <li> 데이터를 삽입할 때는 첫 번째 큐에 enqueue합니다. </li>
      <li> 데이터를 제거할 때는 첫 번째 큐의 요소를 두 번째 큐로 옮기되, 마지막 요소를 제외하고 옮깁니다. 마지막 요소를 dequeue하여 반환하고, 두 큐의 역할을 바꿉니다. 이 방법의 시간 복잡도는 데이터 삽입이 O(1), 데이터 제거가 최악의 경우 O(n)입니다. </li>
    </ul>
    <li> 배열을 이용하여 스택이나 큐를 구현할 수 있습니다. 하지만 배열은 고정된 크기를 가지므로, 스택이나 큐의 크기가 동적으로 변할 경우에는 적합하지 않을 수 있습니다. 또한 배열로 큐를 구현할 경우, 요소를 제거할 때 배열의 모든 요소를 이동시켜야 하므로 시간 복잡도가 O(n)이 됩니다. 이 문제는 동적 배열과 포인터를 이용하여 해결할 수 있습니다. </li>
    <li> Prefix, Infix, Postfix는 연산자의 위치에 따라 표현하는 방식의 차이입니다. </li>
    <ul>
      <li> Prefix(전위 표기법): 연산자를 피연산자 앞에 표기합니다. 예: +AB </li>
      <li> Prefix: 표현식을 뒤에서부터 읽어나갑니다. 피연산자를 만나면 스택에 push하고, 연산자를 만나면 스택에서 두 개의 피연산자를 pop하여 연산한 후 결과를 다시 스택에 push합니다. 이 과정을 끝까지 반복한 후, 스택의 top에 있는 값을 반환합니다. </li>
      <li> Infix(중위 표기법): 연산자를 피연산자 사이에 표기합니다. 예: A+B </li>
      <li> Postfix(후위 표기법): 연산자를 피연산자 뒤에 표기합니다. 예: AB+ 이들을 스택을 이용하여 계산하는 방법은 다음과 같습니다. </li>
      <li> Postfix: 표현식을 앞에서부터 읽어나갑니다. 피연산자를 만나면 스택에 push하고, 연산자를 만나면 스택에서 두 개의 피연산자를 pop하여 연산한 후 결과를 다시 스택에 push합니다. 이 과정을 끝까지 반복한 후, 스택의 top에 있는 값을 반환합니다. </li>
    </ul>
    <li> Deque(Double Ended Queue)는 양쪽 끝에서 삽입과 제거가 모두 가능한 자료구조입니다. 이는 양방향 연결 리스트나 동적 배열을 이용하여 구현할 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary><h3>3. 힙</h3></summary>
  <ul>
    <li> 힙(Heap)은 완전 이진 트리의 한 종류로, 특정한 규칙을 가지고 있는 자료구조입니다. 힙의 종류에는 최대 힙(Max Heap)과 최소 힙(Min Heap)이 있습니다. 최대 힙에서는 부모 노드의 값이 자식 노드의 값보다 항상 크거나 같아야 하며, 최소 힙에서는 부모 노드의 값이 자식 노드의 값보다 항상 작거나 같아야 합니다. </li>
    <li> 힙을 배열로 구현할 수 있습니다. 이때 루트 노드는 인덱스 1에 위치하며, 각 노드의 왼쪽 자식 노드는 부모 노드 인덱스 * 2, 오른쪽 자식 노드는 부모 노드 인덱스 * 2 + 1에 위치합니다. 그리고 각 자식 노드의 부모 노드는 자식 노드 인덱스 / 2에 위치합니다. </li>
    <li> 힙의 삽입 연산은 다음과 같습니다. </li>
    <ul>
      <li> 새로운 값을 힙의 마지막 노드로 삽입합니다. </li>
      <li> 삽입된 노드와 부모 노드를 비교하여 힙의 규칙을 만족하도록 위치를 바꿉니다. 이를 힙이 규칙을 만족할 때까지 반복합니다. </li>
    </ul>
    <li> 힙의 삭제 연산(일반적으로 루트 노드를 삭제)은 다음과 같습니다. </li>
    <ul>
      <li> 루트 노드를 삭제합니다. </li>
      <li> 마지막 노드를 루트 노드로 이동시킵니다. </li>
      <li> 이동된 노드와 자식 노드들을 비교하여 힙의 규칙을 만족하도록 위치를 바꿉니다. 이를 힙이 규칙을 만족할 때까지 반복합니다. </li>
    </ul>
    <li> 힙은 이진 탐색 트리와 달리 편향되지 않는 이유는 힙의 삽입 연산이 완전 이진 트리를 유지하기 때문입니다. 즉, 새로운 노드는 항상 마지막 위치에 삽입되며, 이후 힙의 규칙을 만족하도록 위치가 조정됩니다. </li>
    <li> 힙 정렬의 시간 복잡도는 O(n log n)입니다. 이는 모든 노드에 대해 힙을 재구성하는 과정이 필요하기 때문입니다. 힙 정렬은 Stable한 정렬 방식이 아닙니다. 이는 같은 값을 가진 레코드의 상대적 순서가 정렬 후에 보장되지 않기 때문입니다. </li>
</details>

<details>
  <summary><h3>4. 해시 자료구조</h3></summary>
  <ul>
    <li> 해시 자료구조는 키를 값에 연결시키는 자료구조로, 키를 해시 함수를 통해 해시값으로 변환하고, 이 해시값을 인덱스로 사용하여 값을 저장하거나 검색합니다. 이러한 방식으로 인해 빠른 검색 속도를 제공하며, 일반적으로 O(1)의 시간 복잡도를 가집니다. </li>
    <li> 충돌이 최소화된 해시 함수를 설계하기 위해서는 다음과 같은 원칙을 따르는 것이 좋습니다. </li>
    <ul>
      <li> 균등성: 해시 함수는 가능한 한 모든 해시값에 대해 균등한 분포를 가져야 합니다. 이를 통해 각 버킷에 균등하게 데이터를 분포시킬 수 있습니다. </li>
      <li> 일관성: 같은 키에 대해서는 항상 같은 해시값을 반환해야 합니다. </li>
      <li> 효율성: 해시 함수는 빠르게 계산할 수 있어야 합니다. </li>
    </ul>
    <li> 해시값이 충돌했을 때 처리하는 방법에는 '체이닝(Chaining)'과 '선형 탐사(Linear Probing)', '이중 해싱(Double Hashing)' 등이 있습니다. </li>
    <ul>
      <li> 체이닝은 각 해시 버킷에 연결 리스트를 두어, 충돌이 발생하면 연결 리스트에 데이터를 추가하는 방식입니다. </li>
      <li> 선형 탐사는 충돌이 발생하면, 다음 버킷을 탐사하여 빈 버킷에 데이터를 저장하는 방식입니다. </li>
      <li> 이중 해싱은 선형 탐사와 비슷하지만, 두 번째 해시 함수를 사용하여 탐사 간격을 결정하는 방식입니다. </li>
    </ul>
    <li> JAVA, PYTHON</li>
    <ul>
      <li> Python 언어에서는 체이닝 방식을 사용하여 해시 충돌을 처리하고 있습니다. 딕셔너리에 데이터를 추가할 때, 같은 해시값을 가지는 데이터가 이미 있으면, 연결 리스트에 데이터를 추가합니다. </li>
      <li> Java에서는 주로 체이닝 방식을 사용하여 해시 충돌을 처리합니다. Java의 HashMap 클래스에서는 각 버킷에 연결 리스트를 사용하여 데이터를 저장합니다. 만약 같은 해시값을 가지는 키가 추가되면, 해당 버킷의 연결 리스트에 새로운 노드를 추가합니다. </li>
    </ul>
    <li> Double Hashing의 장점은 선형 탐사 방식에 비해 클러스터링 문제가 적다는 것입니다. 이는 두 번째 해시 함수를 사용하여 탐사 간격을 결정하기 때문에, 동일한 해시값을 가지는 데이터가 같은 위치에 모이는 현상을 줄일 수 있습니다. 따라서 선형 탐사에 비해 일반적으로 더 높은 성능을 제공합니다. 하지만, 단점으로는 두 번째 해시 함수를 계산해야 하므로 추가적인 연산이 필요하다는 것입니다. </li>
    <li> 또한, 두 번째 해시 함수가 0을 반환하면 안 되므로, 해시 함수의 설계가 좀 더 복잡해질 수 있습니다. 이러한 문제를 해결하기 위해, 두 번째 해시 함수를 적절하게 선택하거나, 두 번째 해시 함수의 결과가 0이 아님을 보장하는 방법을 사용할 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary><h3>5. 트리와 이진 트리, 이진 탐색 트리</h3></summary>
  <ul>
    <li> 트리(Tree)는 계층적인 구조를 표현할 때 사용하는 비선형 자료구조로, 노드와 이를 연결하는 간선으로 구성되어 있습니다. 하나의 루트 노드가 있고, 각 노드는 0개 이상의 자식 노드를 가집니다. </li>
    <li> 이진트리(Binary Tree)는 각 노드가 최대 두 개의 자식 노드를 가지는 트리입니다. 이는 왼쪽 자식과 오른쪽 자식, 두 개로 구분됩니다. </li>
    <li> 이진탐색트리(Binary Search Tree, BST)는 이진트리의 일종으로, 각 노드에 대해서 왼쪽 자식 노드들의 값은 현재 노드의 값보다 작거나 같고, 오른쪽 자식 노드들의 값은 현재 노드의 값보다 크다는 특징을 가집니다. </li>
    <li> 그래프와 트리의 차이 </li>
    <ul>
      <li> 그래프는 노드와 노드를 연결하는 간선으로 구성된 자료구조로, 사이클을 허용합니다. </li>
      <li> 트리는 그래프의 한 종류로, 루트에서 시작하여 계층적인 구조를 가지며, 사이클을 허용하지 않습니다. </li>
    </ul>
    <li> 이진탐색트리의 중위탐색 </li>
    <ul>
      <li> 이진탐색트리에서 중위탐색(In-order Traversal)을 수행하면, 노드의 값이 오름차순으로 방문됩니다. 즉, 정렬된 순서대로 값을 얻을 수 있습니다. </li>
    </ul>
    <li> 이진탐색트리 주요 연산의 시간복잡도 </li>
    <ul>
      <li> 검색, 삽입, 삭제 연산 모두 이진탐색트리의 높이에 비례하는 시간복잡도를 가집니다. 즉, 평균적으로 O(log n), 최악의 경우 O(n)의 시간복잡도를 가집니다. </li>
      <li> 이유는 이진탐색트리의 특성 상, 검색, 삽입, 삭제 연산을 수행할 때 루트 노드부터 시작하여 해당 노드까지의 경로를 따라가야 하기 때문입니다. 이 때 트리가 균형잡혀있다면 O(log n)만에 연산을 완료할 수 있지만, 편향된 트리의 경우 최악의 경우 모든 노드를 방문해야 하므로 O(n)의 시간이 걸립니다. </li>
    </ul>
    <li> 이진탐색트리의 한계점 </li>
    <ul>
      <li> 이진탐색트리의 가장 큰 한계점은 트리가 편향되게 구성될 경우 검색 성능이 저하된다는 점입니다. 즉, 입력 자료의 순서에 따라 트리의 높이가 n에 가까워질 수 있어 성능이 저하됩니다. </li>
    </ul>
    <li> 이진탐색트리의 값 삽입, 삭제 방법 및 편향 발생 </li>
    <ul>
      <li> 삽입: 삽입하려는 값과 루트 노드를 비교하여 작으면 왼쪽, 크면 오른쪽으로 이동하면서 삽입 위치를 찾습니다. 이후 새 노드를 삽입합니다. </li>
      <li> 삭제: 삭제하려는 노드를 찾은 후, 해당 노드가 단말 노드라면 그냥 삭제하고, 하나의 자식만 가지는 노드라면 자식 노드를 삭제할 노드의 부모 노드에 연결합니다. 두 개의 자식을 가지는 노드를 삭제할 경우 오른쪽 서브트리의 가장 작은 값을 가진 노드, 또는 왼쪽 서브트리의 가장 큰 값을 가진 노드로 대체합니다. </li>
      <li> 편향 발생: 삽입할 값이 항상 크거나 항상 작은 경우, 즉 삽입할 값이 정렬되어 있는 경우 편향된 트리가 생성됩니다. 이는 트리가 사실상 리스트와 같은 성능을 보여주게 되어, 이진탐색트리의 장점인 검색 성능 향상이 이루어지지 않게 합니다. </li>
    </ul>
  </ul>
</details>
