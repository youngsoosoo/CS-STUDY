<details>
  <summary><h3>1. OSI 7계층?</h3></summary>
  <ul>
    <li> OSI 7계층은 네트워크의 통신 과정을 7개의 계층으로 나눈 모델입니다. </li>
    <ul>
      <li> Physical Layer (물리 계층) : 실제 장치들을 통해 데이터를 전송합니다. </li>
      <li> Data Link Layer (데이터 링크 계층) : 네트워크 기기들 사이의 데이터 전송 및 물리 주소를 관리합니다. </li>
      <li> Network Layer (네트워크 계층) : 다양한 네트워크 간의 통신 경로를 선택합니다. </li>
      <li> Transport Layer (전송 계층) : 호스트 간의 신뢰성 있는 데이터 전송을 담당합니다. </li>
      <li> Session Layer (세션 계층) : 통신 세션을 구성하고 관리합니다. </li>
      <li> Presentation Layer (표현 계층) : 데이터의 표현 방식을 관리하고 암호화합니다. </li>
      <li> Application Layer (응용 계층) : 사용자와 가장 가깝게 위치하며, 사용자의 요청과 응답을 처리합니다. </li>
    </ul>
    <li> Transport Layer는 데이터의 신뢰성 있는 전송을 담당하며, 이를 위해 세그먼트라는 단위로 데이터를 분할하고, 오류 검출, 재전송, 흐름 제어 등을 수행합니다. </li>
    <li> Network Layer는 다양한 네트워크 간의 통신 경로를 선택하고, 이를 위해 패킷이라는 단위로 데이터를 분할합니다. 라우팅, IP 주소 할당 등의 역할을 합니다. </li>
    <li> L3 스위치는 기본적으로 스위치의 기능을 가지면서 라우터의 기능을 일부 가지고 있는 장비로, 빠른 속도로 데이터를 전송하면서도 라우팅 기능을 수행할 수 있습니다. </li>
    <li> 라우터는 네트워크 계층에서 동작하며, 다양한 네트워크 간의 통신 경로를 선택하는 역할을 합니다. </li>
    <li> 각 계층의 단위 </li>
    <ul>
      <li> Physical Layer : Bit </li>
      <li> Data Link Layer : Frame </li>
      <li> Network Layer : Packet </li>
      <li> Transport Layer : Segment </li>
    </ul>
    <li> 헤더의 Packing Order는 데이터가 송신자로부터 수신자로 전송되는 과정에서 각 계층에서 헤더가 추가되는 순서를 의미합니다. 송신 측에서는 Application Layer에서 Physical Layer로 내려가며 헤더가 추가되고, 수신 측에서는 Physical Layer에서 Application Layer로 올라가며 헤더가 제거됩니다. </li>
    <li> ARP (Address Resolution Protocol)는 IP 주소를 물리적 네트워크 주소로 변환하는 프로토콜입니다. 네트워크에서 통신을 하려면 이 두 주소가 모두 필요하기 때문에 ARP는 중요한 역할을 합니다. </li>
  </ul>
</details>

<details>
  <summary><h3>2. TCP, UDP?</h3></summary>
  <ul>
    <li> TCP (Transmission Control Protocol)와 UDP (User Datagram Protocol)는 모두 네트워크에서 데이터를 전송하는 방법을 정의하는 프로토콜입니다. 그러나 두 프로토콜에는 몇 가지 중요한 차이점이 있습니다. </li>
    <ul>
      <li> TCP는 연결 지향적인 프로토콜로, 데이터 전송 전에 통신할 장치 간에 연결을 설정합니다. 이를 통해 데이터의 순서 보장 및 재전송 기능을 제공하므로 신뢰성 있는 데이터 전송을 보장합니다. </li>
      <li> 반면에 UDP는 비연결형 프로토콜로, 데이터 전송 전에 별도의 연결 설정 없이 데이터를 전송합니다. 그래서 TCP보다 빠르지만, 데이터의 순서 보장이나 재전송 기능이 없어 신뢰성이 낮습니다. </li>
    </ul>
    <li> HTTP는 웹 통신에 사용되는 프로토콜로, 웹 페이지의 안정적인 로딩을 보장하기 위해 신뢰성 있는 TCP를 사용합니다. </li>
    <li> 그러나 HTTP/3에서는 QUIC라는 새로운 프로토콜을 도입하였는데, 이는 UDP 위에서 작동하면서 TCP의 신뢰성을 보장하는 기능을 지원합니다. 이렇게 하면 TCP의 느린 속도와 연결 설정에 소요되는 시간을 줄이면서도 신뢰성을 유지할 수 있습니다. </li>
    <li> 새로운 통신 프로토콜을 구현할 때 TCP나 UDP를 선택하는 기준은 그 프로토콜이 필요로 하는 성능과 특성에 따라 달라집니다. 예를 들어, 신뢰성이 중요하고 데이터의 순서가 중요한 경우에는 TCP를, 신속한 데이터 전송이 중요하고 데이터의 손실이 허용되는 경우에는 UDP를 선택할 수 있습니다. </li>
    <li> Checksum은 데이터의 오류를 검출하는 방법입니다. 전송할 데이터에 대한 체크섬 값을 계산하여 데이터와 함께 전송하고, 수신 측에서는 받은 데이터에 대해 체크섬 값을 계산하여 전송된 체크섬 값과 비교합니다. 이 값이 일치하지 않으면 데이터에 오류가 있음을 알 수 있습니다. </li>
    <li> TCP와 UDP 모두 체크섬을 수행하며, 이를 통해 데이터의 오류를 검출할 수 있습니다. 그러나 체크섬은 오류를 검출만 할 뿐, 오류를 정정하지는 않습니다. </li>
    <li> TCP의 신뢰성을 보장하는 방법은 다음과 같습니다 </li>
    <ul>
      <li> 데이터 순서 보장: TCP는 전송할 데이터를 순서대로 번호를 매기고, 수신 측에서는 이 번호를 기준으로 데이터를 재조립합니다. </li>
      <li> 재전송: TCP는 수신 측에서 데이터의 수신을 확인하는 ACK 패킷을 기다리며, 이 패킷을 받지 못하면 데이터를 재전송합니다. </li>
      <li> 흐름 제어: TCP는 수신 측의 데이터 처리 능력을 고려하여 데이터의 전송 속도를 조절합니다. </li>
    </ul>
    <li>  TCP의 혼잡 제어는 네트워크의 혼잡 상황을 감지하고 이에 따라 데이터의 전송 속도를 조절하는 기능입니다. 혼잡 상황을 감지하면 전송 속도를 줄이고, 혼잡이 해소되면 전송 속도를 늘리는 방식으로 네트워크의 성능을 최적화합니다. </li>
  </ul>
</details>

<details>
  <summary><h3>3. DHCP?</h3></summary>
  <ul>
    <li> DHCP (Dynamic Host Configuration Protocol)는 네트워크에 연결된 장치에 자동으로 IP 주소와 기타 네트워크 설정을 제공하는 프로토콜입니다. 이를 통해 네트워크 관리자는 수동으로 각 장치에 IP 주소를 할당할 필요가 없게 됩니다. </li>
    <li> DHCP는 OSI 모델의 Application Layer, 즉 7계층에서 작동합니다. </li>
    <ul>
      <li> DHCP Discover: 클라이언트가 네트워크에 연결되면 DHCP Discover 패킷을 네트워크에 브로드캐스트하여 DHCP 서버를 찾습니다. </li>
      <li> DHCP Offer: DHCP 서버가 이 패킷을 받으면 사용 가능한 IP 주소를 찾아 DHCP Offer 패킷을 클라이언트에게 보냅니다. </li>
      <li> DHCP Request: 클라이언트는 Offer를 받으면 이 IP 주소를 요청하는 DHCP Request 패킷을 서버에게 보냅니다. </li>
      <li> DHCP ACK: 서버는 이 요청을 받고 IP 주소를 클라이언트에게 할당하며, 이를 알리기 위해 DHCP ACK 패킷을 보냅니다. </li>
    </ul>
    <li> DHCP에서 UDP를 사용하는 이유는 DHCP가 신속한 통신을 요구하고, 연결 설정에 시간을 소비할 필요가 없기 때문입니다. 또한, DHCP 통신은 대부분 로컬 네트워크 내에서 이루어지므로 패킷 손실의 가능성이 낮습니다. </li>
    <li> DHCP는 IP 주소 외에도 서브넷 마스크, 기본 게이트웨이, DNS 서버 주소 등의 정보를 제공할 수 있습니다. </li>
    <li> DHCP의 유효기간, 즉 리스 시간은 DHCP 서버 설정에 따라 다르지만 일반적으로는 몇 시간에서 몇 일 사이입니다. 이 기간이 만료되면 클라이언트는 새로운 IP 주소를 요청해야 합니다. </li>
  </ul>
</details>

<details>
  <summary><h3>4. DNS?</h3></summary>
  <ul>
    <li> DNS (Domain Name System)는 사람이 이해하기 쉬운 도메인 이름을 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 시스템입니다. 예를 들어, www.example.com 이라는 도메인 이름을 해당 웹 서버의 IP 주소로 변환합니다. </li>
    <li> DNS는 OSI 모델의 Application Layer, 즉 7계층에서 작동합니다. </li>
    <li> DNS는 주로 UDP를 사용하지만, 쿼리 응답이 512바이트를 초과하거나 특정 상황에서는 TCP를 사용하기도 합니다. </li>
    <li> DNS에서는 Recursive Query와 Iterative Query 두 가지 방식의 쿼리가 있습니다. </li>
    <ul>
      <li> Recursive Query: 클라이언트가 DNS 서버에 쿼리를 보내면, DNS 서버는 요청받은 정보를 찾아서 클라이언트에게 직접 응답합니다. </li>
      <li> Iterative Query: 클라이언트가 DNS 서버에 쿼리를 보내면, DNS 서버는 요청받은 정보를 찾아서 다른 DNS 서버를 가리키는 정보를 클라이언트에게 응답합니다. 그런 다음 클라이언트는 해당 DNS 서버에 다시 쿼리를 보냅니다. </li>
    </ul>
    <li> DNS 쿼리 과정에서 손실이 발생하면, 클라이언트는 일정 시간 후에 쿼리를 다시 보내는 방식으로 처리합니다. </li>
    <li> DNS 레코드 타입 중 A, CNAME, AAAA의 차이는 다음과 같습니다. </li>
    <ul>
      <li> A 레코드: 도메인 이름을 IPv4 주소로 변환합니다. </li>
      <li> CNAME 레코드: 도메인 이름을 다른 도메인 이름으로 변환합니다. 일종의 별칭을 제공하는 역할을 합니다. </li>
      <li> AAAA 레코드: 도메인 이름을 IPv6 주소로 변환합니다. </li>
    </ul>
    <li> hosts 파일은 도메인 이름과 IP 주소의 매핑을 저장하는 시스템 파일입니다. DNS 조회 전에 hosts 파일을 먼저 확인하여 해당 도메인 이름의 IP 주소가 있는지 확인합니다. 따라서 hosts 파일의 우선순위가 DNS보다 높습니다. 이를 통해 DNS 조회 없이도 도메인 이름을 IP 주소로 변환할 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary><h3>5. IP?</h3></summary>
  <ul>
    <li> IP 주소 (Internet Protocol Address)는 인터넷에 연결된 장치를 식별하고 위치를 지정하는 데 사용되는 고유한 주소입니다. 이를 통해 데이터 패킷이 올바른 목적지로 전송될 수 있습니다. </li>
    <li> IPv4 주소 고갈 문제는 여러 가지 방법으로 해결할 수 있습니다. 가장 흔한 방법은 NAT (Network Address Translation) 기술을 사용하여 사설 IP 주소를 공인 IP 주소로 변환하는 것입니다. 또한, CIDR (Classless Inter-Domain Routing) 방식을 통해 IP 주소 공간을 더 효율적으로 사용하거나, IPv6를 도입하여 주소 공간을 확장하는 방법도 있습니다. </li>
    <li> IPv4와 IPv6의 주요 차이점. </li>
    <ul>
      <li> 주소 크기: IPv4는 32비트 주소를 사용하여 약 43억 개의 주소를 제공하는 반면, IPv6는 128비트 주소를 사용하여 더 많은 주소를 제공합니다. </li>
      <li> 주소 표현 방식: IPv4 주소는 점으로 구분된 4개의 10진수로 표현되며, IPv6 주소는 콜론으로 구분된 8개의 16진수로 표현됩니다. </li>
    </ul>
    <li> IPv4를 사용하는 장비와 IPv6를 사용하는 장비가 같은 네트워크에서 통신하려면, 터널링이나 듀얼 스택과 같은 특별한 기술이 필요합니다. </li>
    <li> IP 프로토콜 자체는 패킷의 손실, 순서 변경, 중복 등에 대해 보장하지 않습니다. 이러한 기능은 TCP와 같은 상위 계층의 프로토콜에서 처리합니다. </li>
    <li> IPv4에서 수행하는 Checksum은 헤더의 오류를 검출하기 위한 것이며, TCP에서 수행하는 Checksum은 전체 패킷의 오류를 검출하기 위한 것입니다. </li>
    <li> TTL (Time to Live) 또는 Hop Limit은 패킷이 네트워크에서 얼마나 오래 살아있을 수 있는지를 나타내는 값입니다. 이 값이 0이 되면 패킷은 삭제됩니다. </li>
    <li> IP 주소는 장치를 네트워크 상에서 고유하게 식별하는 데 사용되며, MAC 주소는 네트워크 카드의 물리적인 주소를 나타냅니다. IP 주소는 동적으로 변경될 수 있지만, MAC 주소는 장비의 하드웨어에 고정되어 있습니다. </li>
  </ul>
</details>

<details>
  <summary><h3>5-1. CheckSum?</h3></summary>
  <ul>
    <li> Checksum은 데이터의 무결성을 확인하기 위해 사용되는 간단한 오류 검출 방법입니다. 데이터의 각 비트를 더하거나 XOR 연산을 수행하는 등의 방법으로 생성됩니다. </li>
    <ul>
      <li> 데이터를 전송할 때, 데이터와 함께 생성된 checksum을 함께 보냅니다.  </li>
      <li> 수신자는 받은 데이터로 동일한 방법으로 checksum을 다시 계산하고, 받은 checksum과 비교합니다.  </li>
      <li> checksum이 일치하면 데이터가 정확하게 전송되었다고 판단하고, 일치하지 않으면 데이터에 오류가 있음을 알 수 있습니다. </li>
    </ul>
    <li> Checksum은 간단하고 빠르게 계산할 수 있는 장점이 있지만, 고급 오류 검출 기능을 제공하지 않습니다. </li>
    <li> 예를 들어, 두 비트가 동시에 변경되면 checksum이 동일하게 유지될 수 있어 이런 오류를 검출하지 못할 수 있습니다. 이런 이유로, 더 복잡한 오류 검출 및 복구 기능이 필요한 경우에는 CRC (Cyclic Redundancy Check), 해시 함수, 패리티 비트, ECC (Error Correction Code) 등의 방법이 사용됩니다. </li>
  </ul>
</details>

<details>
  <summary><h3>6. WebSocker과 Socket 통신?</h3></summary>
  <ul>
    <li> 웹소켓과 소켓 통신은 비슷한 개념이지만 사용되는 환경과 목적이 다릅니다. </li>
    <ul>
      <li> 소켓 통신: 네트워크 상에서 두 대의 컴퓨터가 데이터를 주고받는 통신 방식입니다. TCP/IP 프로토콜을 기반으로 하며, 서버와 클라이언트 간의 연결이 지속적으로 유지되어 실시간 통신이 가능합니다. </li>
      <li> 웹소켓: 웹 환경에서 실시간 양방향 통신을 가능하게 하는 프로토콜입니다. 기존의 HTTP 프로토콜이 요청-응답 패턴으로 동작하는 데 반해, 웹소켓은 서버와 클라이언트 사이에 지속적인 연결을 유지하고, 양방향 통신을 가능하게 합니다. </li>
    </ul>
    <li> 소켓과 포트의 차이 </li>
    <ul>
      <li> 소켓: 네트워크 통신을 위한 인터페이스로, IP 주소와 포트 번호의 조합으로 구성됩니다. 소켓을 통해 데이터를 송수신합니다. </li>
      <li> 포트: 네트워크 서비스가 운영되는 논리적인 접근 지점입니다. 한 대의 컴퓨터 내에서 여러 개의 서비스가 동시에 운영될 수 있게 하며, 각 서비스는 고유의 포트 번호를 갖습니다. </li>
    </ul>
    <li> 여러 소켓이 있을 때, 각 소켓의 포트 번호는 모두 다를 수 있습니다. 같은 컴퓨터 내에서 여러 개의 서비스가 동시에 운영될 때, 서비스를 구분하기 위해 각각 다른 포트 번호를 사용합니다. 하지만 다른 IP 주소에서 온 연결 요청이라면 같은 포트 번호를 사용하는 것도 가능합니다. </li>
  </ul>
</details>

<details>
  <summary><h3>7. HTTP?</h3></summary>
  <ul>
    <li> HTTP (HyperText Transfer Protocol)는 웹에서 정보를 주고받기 위한 프로토콜입니다. </li>
    <li> 클라이언트에서 서버로 요청을 보내고, 서버에서는 이에 대한 응답을 보내는 방식으로 동작합니다. HTTP는 상태를 유지하지 않는(stateless) 프로토콜로, 각 요청과 응답이 독립적입니다. </li>
    <li> 공개키와 대칭키는 암호화 방식에서 사용되는 두 가지 주요 키 종류입니다. </li>
    <ul>
      <li> 공개키: 두 개의 키(공개키와 개인키)를 사용하는 방식으로, 하나의 키로 암호화하면 다른 키로만 복호화할 수 있습니다. 이를 통해 정보를 안전하게 전송할 수 있습니다. </li>
      <li> 대칭키: 암호화와 복호화에 같은 키를 사용하는 방식입니다. 처리 속도가 빠르지만, 키를 안전하게 교환하는 문제가 있습니다. </li>
    </ul>
    <li> HTTPS Handshake 과정에서 인증서를 사용하는 이유는 서버의 신원을 확인하고, 클라이언트와 서버 간에 공유할 비밀키를 안전하게 교환하기 위해서입니다. 인증서는 신뢰할 수 있는 CA(Certificate Authority)에 의해 발행되며, 서버의 공개키와 서버의 신원 정보를 포함하고 있습니다. </li>
    <li> SSL(Secure Sockets Layer)과 TLS(Transport Layer Security)는 둘 다 데이터를 안전하게 전송하기 위한 프로토콜입니다. SSL은 Netscape에서 처음 개발되었고, 그 후에 IETF의 표준인 TLS로 발전하였습니다. TLS는 SSL 3.0 버전을 기반으로 개발되었으며, 보안 강화를 위한 여러 개선 사항이 포함되어 있습니다. 현재는 대부분의 웹 브라우저와 서버가 TLS를 지원하고 있습니다. </li>
  </ul>
</details>

<details>
  <summary><h3>7-1. HTTP Method?</h3></summary>
  <ul>
    <li> HTTP 메소드는 HTTP 프로토콜에서 요청의 종류를 정의하는 방법입니다. 주요 HTTP 메소드에는 다음과 같은 것들이 있습니다. </li>
    <ul>
      <li> GET: 특정 리소스의 표현을 요청합니다. </li>
      <li> POST: 특정 리소스에 데이터를 전송하여 처리를 요청합니다. </li>
      <li> PUT: 특정 리소스의 상태를 업데이트하거나, 존재하지 않는 경우 새로 생성합니다. </li>
      <li> DELETE: 특정 리소스를 삭제합니다. </li>
      <li> PATCH: 리소스의 일부만을 수정합니다. </li>
      <li> HEAD: GET과 동일하지만, 본문을 제외하고 헤더 정보만 요청합니다. </li>
      <li> OPTIONS: 특정 리소스에 대해 사용 가능한 메소드를 조회합니다. </li>
    </ul>
    <li> HTTP 메소드의 멱등성(idempotence)은 동일한 요청을 여러 번 보내도 결과가 변하지 않는 특성을 말합니다. 예를 들어, GET, PUT, DELETE 등의 메소드는 멱등성을 가지고 있습니다. </li>
    <li> GET과 POST의 주요 차이점은 다음과 같습니다. </li>
    <ul>
      <li> GET: 서버로부터 정보를 조회하기 위해 사용되며, 요청 정보를 URL에 포함하여 전송합니다. </li>
      <li> POST: 클라이언트에서 서버로 어떤 정보를 전송하기 위해 사용되며, 요청 정보를 HTTP 메시지의 본문에 담아 전송합니다. </li>
    </ul>
    <li> POST와 PUT, PATCH의 차이는 다음과 같습니다. </li>
    <ul>
      <li> POST: 서버에 새로운 리소스를 생성하기 위해 사용됩니다. </li>
      <li> PUT: 서버의 특정 리소스를 완전히 대체하기 위해 사용됩니다. </li>
      <li> PATCH: 서버의 특정 리소스의 일부만을 변경하기 위해 사용됩니다. </li>
    </ul>
    <li> HTTP 1.1 이후로 GET 메소드에서도 본문(Body)을 통해 데이터를 전송할 수 있게 되었지만, 이 방식은 여전히 지양됩니다. 이는 주로 GET이 설계 원리와 관례에 따라 본문을 포함하지 않는 방식으로 사용되기 때문입니다. GET은 리소스를 조회하는 데 사용되며, 본문이 아닌 URL의 쿼리 파라미터를 통해 필요한 정보를 전달하는 것이 일반적입니다. 또한, 일부 웹 서버와 프록시, 캐싱 시스템 등에서는 GET 요청의 본문을 무시하거나 오류를 반환하는 경우도 있어, 호환성 문제가 발생할 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary><h3>7-2. HTTP 응답 코드?</h3></summary>
  <ul>
    <li> HTTP 응답 코드는 클라이언트의 요청이 어떻게 처리되었는지를 나타내는 세 자리 숫자입니다. </li>
    <ul>
      <li> 1xx (정보): 요청을 받았고, 프로세스를 계속 진행 중임을 나타냅니다. </li>
      <li> 2xx (성공): 요청이 성공적으로 받았으며, 이해되었고, 수락되었음을 나타냅니다. </li>
      <li> 3xx (리다이렉션): 클라이언트는 요청을 완료하기 위해 추가 작업을 해야 함을 나타냅니다. </li>
      <li> 4xx (클라이언트 오류): 요청 문법이 잘못되었거나 요청을 처리할 수 없음을 나타냅니다. </li>
      <li> 5xx (서버 오류): 서버가 명백히 유효한 요청에 대해 충족할 수 없음을 나타냅니다. </li>
    </ul>
    <li> 401 (Unauthorized)와 403 (Forbidden)의 차이는 다음과 같습니다. </li>
    <ul>
      <li> 401 (Unauthorized): 클라이언트가 자신을 인증하기 위한 정보를 제공하지 않았을 때 서버가 반환하는 응답 코드입니다. 클라이언트는 인증 정보를 제공하여 다시 요청할 수 있습니다. </li>
      <li> 403 (Forbidden): 클라이언트가 요청한 리소스에 대한 접근 권한이 없을 때 서버가 반환하는 응답 코드입니다. 403 응답은 클라이언트가 리소스에 접근하는 것이 완전히 금지된 경우를 나타냅니다. </li>
    </ul>
    <li> 200 (OK)와 201 (Created)의 차이는 다음과 같습니다. </li>
    <ul>
      <li> 200 (OK): 요청이 성공적으로 처리되었음을 나타냅니다. GET, HEAD, POST, PUT, PATCH 등의 요청 메소드에 사용될 수 있습니다. </li>
      <li> 201 (Created): 클라이언트의 요청이 성공적으로 수행되어 새로운 리소스가 생성되었음을 나타냅니다. 주로 POST 요청에 대한 응답으로 사용됩니다. 이 응답은 생성된 리소스의 URI를 포함하는 Location 헤더를 통해 클라이언트에게 반환됩니다. </li>
    </ul>
  </ul>
</details>

<details>
  <summary><h3>8. 3-Way Handshake</h3></summary>
  <ul>
    <li> TCP/IP 프로토콜에서 연결을 시작하기 위해 사용되는 방법입니다. </li>
    <li> 클라이언트가 서버에 SYN 패킷을 보내고 (SYN: synchronize sequence numbers), 서버가 SYN과 ACK(acknowledgement) 패킷을 보내 응답하며, 마지막으로 클라이언트가 ACK 패킷을 보내어 연결을 확정하는 과정을 거칩니다. </li>
    <li> SYN과 ACK는 TCP 헤더에 플래그로 설정되어 전달됩니다. </li>
    <li> SYN 플래그는 연결 설정 요청을 나타내며, ACK 플래그는 이전 패킷을 성공적으로 수신했음을 나타냅니다. </li>
    <li> 2-Way Handshaking만 사용하면, 데이터가 전송되는 동안 네트워크의 상태 변화를 감지할 수 없습니다. 따라서, ACK를 통해 양방향 통신이 성립되었음을 확실히 확인할 수 있는 3-Way Handshaking이 사용됩니다. </li>
    <li> 두 호스트가 동시에 연결을 시도하면, 각자가 상대방의 연결 요청을 독립적으로 처리하게 됩니다. 이를 통해 두 개의 독립적인 연결이 형성됩니다. 이러한 현상을 '동시 개방(Simultaneous Open)'이라고 합니다. </li>
    <li> YN Flooding은 DoS(Denial of Service) 공격 유형 중 하나로, 공격자가 대량의 SYN 패킷을 목표 서버에 보내 연결 큐를 가득 채워 다른 정상적인 연결 요청을 처리할 수 없게 만드는 공격입니다. 이로 인해 서버의 자원을 고갈시키고 서비스를 불능 상태로 만들 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary><h3>9. 4-Way Handshake</h3></summary>
  <ul>
    <li> 4-Way Handshake는 TCP/IP 프로토콜에서 연결을 종료하기 위해 사용되는 방법입니다. </li>
    <li> 클라이언트가 서버에 FIN 패킷을 보내 연결 종료를 요청하고 (FIN: finish), 서버는 이를 ACK 패킷으로 확인합니다. 그 다음, 서버도 클라이언트에게 FIN 패킷을 보내 연결 종료를 요청하고, 마지막으로 클라이언트가 이를 ACK 패킷으로 확인하여 연결을 종료합니다. </li>
    <li> TCP 헤더의 플래그를 확인함으로써 패킷이 4-Way Handshake를 위한 것인지 파악할 수 있습니다. FIN 플래그가 세팅된 패킷은 연결 종료를 목적으로 합니다. </li>
    <li> RST(Reset) 패킷을 보내어 강제로 연결을 종료할 수 있습니다. RST 패킷은 에러 상황에서 사용되거나, 특정 조건에서 연결을 즉시 끊어야 할 경우에 사용됩니다. </li>
    <li> TCP는 재전송 메커니즘을 통해 연결 상태를 확인합니다. 특정 시간 동안 ACK 패킷을 받지 못하면, 연결이 끊어진 것으로 간주하고 재전송을 시도합니다. 여러 번의 재전송에도 실패하면, 연결이 강제로 종료된 것으로 판단하게 됩니다. </li>
    <li> 연결 종료 후에 바로 끝나지 않고 TIME_WAIT 상태로 대기하는 이유는 네트워크 상의 지연이나 순서가 뒤바뀐 패킷 등으로 인해 이전 연결의 패킷이 새 연결에서 잘못 해석되는 것을 방지하기 위함입니다. 이 상태는 보통 MSL(Maximum Segment Lifetime)의 두 배인 시간동안 유지됩니다. </li>
  </ul>
</details>
