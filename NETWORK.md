<details>
  <summary><h3>1. OSI 7계층?</h3></summary>
  <ul>
    <li> OSI 7계층은 네트워크의 통신 과정을 7개의 계층으로 나눈 모델입니다. </li>
    <ul>
      <li> Physical Layer (물리 계층) : 실제 장치들을 통해 데이터를 전송합니다. </li>
      <li> Data Link Layer (데이터 링크 계층) : 네트워크 기기들 사이의 데이터 전송 및 물리 주소를 관리합니다. </li>
      <li> Network Layer (네트워크 계층) : 다양한 네트워크 간의 통신 경로를 선택합니다. </li>
      <li> Transport Layer (전송 계층) : 호스트 간의 신뢰성 있는 데이터 전송을 담당합니다. </li>
      <li> Session Layer (세션 계층) : 통신 세션을 구성하고 관리합니다. </li>
      <li> Presentation Layer (표현 계층) : 데이터의 표현 방식을 관리하고 암호화합니다. </li>
      <li> Application Layer (응용 계층) : 사용자와 가장 가깝게 위치하며, 사용자의 요청과 응답을 처리합니다. </li>
    </ul>
    <li> Transport Layer는 데이터의 신뢰성 있는 전송을 담당하며, 이를 위해 세그먼트라는 단위로 데이터를 분할하고, 오류 검출, 재전송, 흐름 제어 등을 수행합니다. </li>
    <li> Network Layer는 다양한 네트워크 간의 통신 경로를 선택하고, 이를 위해 패킷이라는 단위로 데이터를 분할합니다. 라우팅, IP 주소 할당 등의 역할을 합니다. </li>
    <li> L3 스위치는 기본적으로 스위치의 기능을 가지면서 라우터의 기능을 일부 가지고 있는 장비로, 빠른 속도로 데이터를 전송하면서도 라우팅 기능을 수행할 수 있습니다. </li>
    <li> 라우터는 네트워크 계층에서 동작하며, 다양한 네트워크 간의 통신 경로를 선택하는 역할을 합니다. </li>
    <li> 각 계층의 단위 </li>
    <ul>
      <li> Physical Layer : Bit </li>
      <li> Data Link Layer : Frame </li>
      <li> Network Layer : Packet </li>
      <li> Transport Layer : Segment </li>
    </ul>
    <li> 헤더의 Packing Order는 데이터가 송신자로부터 수신자로 전송되는 과정에서 각 계층에서 헤더가 추가되는 순서를 의미합니다. 송신 측에서는 Application Layer에서 Physical Layer로 내려가며 헤더가 추가되고, 수신 측에서는 Physical Layer에서 Application Layer로 올라가며 헤더가 제거됩니다. </li>
    <li> ARP (Address Resolution Protocol)는 IP 주소를 물리적 네트워크 주소로 변환하는 프로토콜입니다. 네트워크에서 통신을 하려면 이 두 주소가 모두 필요하기 때문에 ARP는 중요한 역할을 합니다. </li>
  </ul>
</details>

<details>
  <summary><h3>2. TCP, UDP?</h3></summary>
  <ul>
    <li> TCP (Transmission Control Protocol)와 UDP (User Datagram Protocol)는 모두 네트워크에서 데이터를 전송하는 방법을 정의하는 프로토콜입니다. 그러나 두 프로토콜에는 몇 가지 중요한 차이점이 있습니다. </li>
    <ul>
      <li> TCP는 연결 지향적인 프로토콜로, 데이터 전송 전에 통신할 장치 간에 연결을 설정합니다. 이를 통해 데이터의 순서 보장 및 재전송 기능을 제공하므로 신뢰성 있는 데이터 전송을 보장합니다. </li>
      <li> 반면에 UDP는 비연결형 프로토콜로, 데이터 전송 전에 별도의 연결 설정 없이 데이터를 전송합니다. 그래서 TCP보다 빠르지만, 데이터의 순서 보장이나 재전송 기능이 없어 신뢰성이 낮습니다. </li>
    </ul>
    <li> HTTP는 웹 통신에 사용되는 프로토콜로, 웹 페이지의 안정적인 로딩을 보장하기 위해 신뢰성 있는 TCP를 사용합니다. </li>
    <li> 그러나 HTTP/3에서는 QUIC라는 새로운 프로토콜을 도입하였는데, 이는 UDP 위에서 작동하면서 TCP의 신뢰성을 보장하는 기능을 지원합니다. 이렇게 하면 TCP의 느린 속도와 연결 설정에 소요되는 시간을 줄이면서도 신뢰성을 유지할 수 있습니다. </li>
    <li> 새로운 통신 프로토콜을 구현할 때 TCP나 UDP를 선택하는 기준은 그 프로토콜이 필요로 하는 성능과 특성에 따라 달라집니다. 예를 들어, 신뢰성이 중요하고 데이터의 순서가 중요한 경우에는 TCP를, 신속한 데이터 전송이 중요하고 데이터의 손실이 허용되는 경우에는 UDP를 선택할 수 있습니다. </li>
    <li> Checksum은 데이터의 오류를 검출하는 방법입니다. 전송할 데이터에 대한 체크섬 값을 계산하여 데이터와 함께 전송하고, 수신 측에서는 받은 데이터에 대해 체크섬 값을 계산하여 전송된 체크섬 값과 비교합니다. 이 값이 일치하지 않으면 데이터에 오류가 있음을 알 수 있습니다. </li>
    <li> TCP와 UDP 모두 체크섬을 수행하며, 이를 통해 데이터의 오류를 검출할 수 있습니다. 그러나 체크섬은 오류를 검출만 할 뿐, 오류를 정정하지는 않습니다. </li>
    <li> TCP의 신뢰성을 보장하는 방법은 다음과 같습니다 </li>
    <ul>
      <li> 데이터 순서 보장: TCP는 전송할 데이터를 순서대로 번호를 매기고, 수신 측에서는 이 번호를 기준으로 데이터를 재조립합니다. </li>
      <li> 재전송: TCP는 수신 측에서 데이터의 수신을 확인하는 ACK 패킷을 기다리며, 이 패킷을 받지 못하면 데이터를 재전송합니다. </li>
      <li> 흐름 제어: TCP는 수신 측의 데이터 처리 능력을 고려하여 데이터의 전송 속도를 조절합니다. </li>
    </ul>
    <li>  TCP의 혼잡 제어는 네트워크의 혼잡 상황을 감지하고 이에 따라 데이터의 전송 속도를 조절하는 기능입니다. 혼잡 상황을 감지하면 전송 속도를 줄이고, 혼잡이 해소되면 전송 속도를 늘리는 방식으로 네트워크의 성능을 최적화합니다. </li>
  </ul>
</details>

<details>
  <summary><h3>3. DHCP?</h3></summary>
  <ul>
    <li> DHCP (Dynamic Host Configuration Protocol)는 네트워크에 연결된 장치에 자동으로 IP 주소와 기타 네트워크 설정을 제공하는 프로토콜입니다. 이를 통해 네트워크 관리자는 수동으로 각 장치에 IP 주소를 할당할 필요가 없게 됩니다. </li>
    <li> DHCP는 OSI 모델의 Application Layer, 즉 7계층에서 작동합니다. </li>
    <ul>
      <li> DHCP Discover: 클라이언트가 네트워크에 연결되면 DHCP Discover 패킷을 네트워크에 브로드캐스트하여 DHCP 서버를 찾습니다. </li>
      <li> DHCP Offer: DHCP 서버가 이 패킷을 받으면 사용 가능한 IP 주소를 찾아 DHCP Offer 패킷을 클라이언트에게 보냅니다. </li>
      <li> DHCP Request: 클라이언트는 Offer를 받으면 이 IP 주소를 요청하는 DHCP Request 패킷을 서버에게 보냅니다. </li>
      <li> DHCP ACK: 서버는 이 요청을 받고 IP 주소를 클라이언트에게 할당하며, 이를 알리기 위해 DHCP ACK 패킷을 보냅니다. </li>
    </ul>
    <li> DHCP에서 UDP를 사용하는 이유는 DHCP가 신속한 통신을 요구하고, 연결 설정에 시간을 소비할 필요가 없기 때문입니다. 또한, DHCP 통신은 대부분 로컬 네트워크 내에서 이루어지므로 패킷 손실의 가능성이 낮습니다. </li>
    <li> DHCP는 IP 주소 외에도 서브넷 마스크, 기본 게이트웨이, DNS 서버 주소 등의 정보를 제공할 수 있습니다. </li>
    <li> DHCP의 유효기간, 즉 리스 시간은 DHCP 서버 설정에 따라 다르지만 일반적으로는 몇 시간에서 몇 일 사이입니다. 이 기간이 만료되면 클라이언트는 새로운 IP 주소를 요청해야 합니다. </li>
  </ul>
</details>

<details>
  <summary><h3>4. DNS?</h3></summary>
  <ul>
    <li> DNS (Domain Name System)는 사람이 이해하기 쉬운 도메인 이름을 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 시스템입니다. 예를 들어, www.example.com 이라는 도메인 이름을 해당 웹 서버의 IP 주소로 변환합니다. </li>
    <li> DNS는 OSI 모델의 Application Layer, 즉 7계층에서 작동합니다. </li>
    <li> DNS는 주로 UDP를 사용하지만, 쿼리 응답이 512바이트를 초과하거나 특정 상황에서는 TCP를 사용하기도 합니다. </li>
    <li> DNS에서는 Recursive Query와 Iterative Query 두 가지 방식의 쿼리가 있습니다. </li>
    <ul>
      <li> Recursive Query: 클라이언트가 DNS 서버에 쿼리를 보내면, DNS 서버는 요청받은 정보를 찾아서 클라이언트에게 직접 응답합니다. </li>
      <li> Iterative Query: 클라이언트가 DNS 서버에 쿼리를 보내면, DNS 서버는 요청받은 정보를 찾아서 다른 DNS 서버를 가리키는 정보를 클라이언트에게 응답합니다. 그런 다음 클라이언트는 해당 DNS 서버에 다시 쿼리를 보냅니다. </li>
    </ul>
    <li> DNS 쿼리 과정에서 손실이 발생하면, 클라이언트는 일정 시간 후에 쿼리를 다시 보내는 방식으로 처리합니다. </li>
    <li> DNS 레코드 타입 중 A, CNAME, AAAA의 차이는 다음과 같습니다. </li>
    <ul>
      <li> A 레코드: 도메인 이름을 IPv4 주소로 변환합니다. </li>
      <li> CNAME 레코드: 도메인 이름을 다른 도메인 이름으로 변환합니다. 일종의 별칭을 제공하는 역할을 합니다. </li>
      <li> AAAA 레코드: 도메인 이름을 IPv6 주소로 변환합니다. </li>
    </ul>
    <li> hosts 파일은 도메인 이름과 IP 주소의 매핑을 저장하는 시스템 파일입니다. DNS 조회 전에 hosts 파일을 먼저 확인하여 해당 도메인 이름의 IP 주소가 있는지 확인합니다. 따라서 hosts 파일의 우선순위가 DNS보다 높습니다. 이를 통해 DNS 조회 없이도 도메인 이름을 IP 주소로 변환할 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary><h3>5. IP?</h3></summary>
  <ul>
    <li> IP 주소 (Internet Protocol Address)는 인터넷에 연결된 장치를 식별하고 위치를 지정하는 데 사용되는 고유한 주소입니다. 이를 통해 데이터 패킷이 올바른 목적지로 전송될 수 있습니다. </li>
    <li> IPv4 주소 고갈 문제는 여러 가지 방법으로 해결할 수 있습니다. 가장 흔한 방법은 NAT (Network Address Translation) 기술을 사용하여 사설 IP 주소를 공인 IP 주소로 변환하는 것입니다. 또한, CIDR (Classless Inter-Domain Routing) 방식을 통해 IP 주소 공간을 더 효율적으로 사용하거나, IPv6를 도입하여 주소 공간을 확장하는 방법도 있습니다. </li>
    <li> IPv4와 IPv6의 주요 차이점. </li>
    <ul>
      <li> 주소 크기: IPv4는 32비트 주소를 사용하여 약 43억 개의 주소를 제공하는 반면, IPv6는 128비트 주소를 사용하여 더 많은 주소를 제공합니다. </li>
      <li> 주소 표현 방식: IPv4 주소는 점으로 구분된 4개의 10진수로 표현되며, IPv6 주소는 콜론으로 구분된 8개의 16진수로 표현됩니다. </li>
    </ul>
    <li> IPv4를 사용하는 장비와 IPv6를 사용하는 장비가 같은 네트워크에서 통신하려면, 터널링이나 듀얼 스택과 같은 특별한 기술이 필요합니다. </li>
    <li> IP 프로토콜 자체는 패킷의 손실, 순서 변경, 중복 등에 대해 보장하지 않습니다. 이러한 기능은 TCP와 같은 상위 계층의 프로토콜에서 처리합니다. </li>
    <li> IPv4에서 수행하는 Checksum은 헤더의 오류를 검출하기 위한 것이며, TCP에서 수행하는 Checksum은 전체 패킷의 오류를 검출하기 위한 것입니다. </li>
    <li> TTL (Time to Live) 또는 Hop Limit은 패킷이 네트워크에서 얼마나 오래 살아있을 수 있는지를 나타내는 값입니다. 이 값이 0이 되면 패킷은 삭제됩니다. </li>
    <li> IP 주소는 장치를 네트워크 상에서 고유하게 식별하는 데 사용되며, MAC 주소는 네트워크 카드의 물리적인 주소를 나타냅니다. IP 주소는 동적으로 변경될 수 있지만, MAC 주소는 장비의 하드웨어에 고정되어 있습니다. </li>
  </ul>
</details>

<details>
  <summary><h3>5-1. CheckSum?</h3></summary>
  <ul>
    <li> Checksum은 데이터의 무결성을 확인하기 위해 사용되는 간단한 오류 검출 방법입니다. 데이터의 각 비트를 더하거나 XOR 연산을 수행하는 등의 방법으로 생성됩니다. </li>
    <ul>
      <li> 데이터를 전송할 때, 데이터와 함께 생성된 checksum을 함께 보냅니다.  </li>
      <li> 수신자는 받은 데이터로 동일한 방법으로 checksum을 다시 계산하고, 받은 checksum과 비교합니다.  </li>
      <li> checksum이 일치하면 데이터가 정확하게 전송되었다고 판단하고, 일치하지 않으면 데이터에 오류가 있음을 알 수 있습니다. </li>
    </ul>
    <li> Checksum은 간단하고 빠르게 계산할 수 있는 장점이 있지만, 고급 오류 검출 기능을 제공하지 않습니다. </li>
    <li> 예를 들어, 두 비트가 동시에 변경되면 checksum이 동일하게 유지될 수 있어 이런 오류를 검출하지 못할 수 있습니다. 이런 이유로, 더 복잡한 오류 검출 및 복구 기능이 필요한 경우에는 CRC (Cyclic Redundancy Check), 해시 함수, 패리티 비트, ECC (Error Correction Code) 등의 방법이 사용됩니다. </li>
  </ul>
</details>

<details>
  <summary><h3>6. WebSocker과 Socket 통신?</h3></summary>
  <ul>
    <li> 웹소켓과 소켓 통신은 비슷한 개념이지만 사용되는 환경과 목적이 다릅니다. </li>
    <ul>
      <li> 소켓 통신: 네트워크 상에서 두 대의 컴퓨터가 데이터를 주고받는 통신 방식입니다. TCP/IP 프로토콜을 기반으로 하며, 서버와 클라이언트 간의 연결이 지속적으로 유지되어 실시간 통신이 가능합니다. </li>
      <li> 웹소켓: 웹 환경에서 실시간 양방향 통신을 가능하게 하는 프로토콜입니다. 기존의 HTTP 프로토콜이 요청-응답 패턴으로 동작하는 데 반해, 웹소켓은 서버와 클라이언트 사이에 지속적인 연결을 유지하고, 양방향 통신을 가능하게 합니다. </li>
    </ul>
    <li> 소켓과 포트의 차이 </li>
    <ul>
      <li> 소켓: 네트워크 통신을 위한 인터페이스로, IP 주소와 포트 번호의 조합으로 구성됩니다. 소켓을 통해 데이터를 송수신합니다. </li>
      <li> 포트: 네트워크 서비스가 운영되는 논리적인 접근 지점입니다. 한 대의 컴퓨터 내에서 여러 개의 서비스가 동시에 운영될 수 있게 하며, 각 서비스는 고유의 포트 번호를 갖습니다. </li>
    </ul>
    <li> 여러 소켓이 있을 때, 각 소켓의 포트 번호는 모두 다를 수 있습니다. 같은 컴퓨터 내에서 여러 개의 서비스가 동시에 운영될 때, 서비스를 구분하기 위해 각각 다른 포트 번호를 사용합니다. 하지만 다른 IP 주소에서 온 연결 요청이라면 같은 포트 번호를 사용하는 것도 가능합니다. </li>
  </ul>
</details>
