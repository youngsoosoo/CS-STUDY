## 운영체제

<details>
  <summary><h3>1. 시스템 콜이 무엇인지 설명해 주세요.</h3></summary>
    <ul>
      <li>시스템 콜이란 사용자 레벨의 프로세스가 운영체제의 서비스를 요청하기 위해 사용하는 인터페이스를 말합니다. 이를 통해 운영체제가 제공하는 다양한 기능들을 안전하게 사용할 수 있습니다.</li>
      <li>시스템 콜의 예시로는 파일 열기(open), 파일 읽기(read), 파일 쓰기(write), 프로세스 생성(fork), 메모리 할당(malloc) 등이 있습니다.</li>
      <li>시스템 콜이 실행되는 과정은 다음과 같습니다</li>
        <ul>
          <li>사용자 프로세스가 시스템 콜을 요청하면, 운영체제는 해당 요청을 받아서 검증합니다.</li>
          <li>검증이 끝나면, 운영체제는 커널 모드로 전환하여 요청된 서비스를 수행합니다.</li>
          <li>서비스가 완료되면, 운영체제는 다시 사용자 모드로 전환하고, 사용자 프로세스에게 제어를 반환합니다.</li>
        </ul>
      <li>시스템 콜의 유형에는 프로세스 제어, 파일 관리, 장치 관리, 정보 유지, 통신 등이 있습니다.</li>
      <li>운영체제의 Dual Mode란 사용자 모드와 커널 모드를 구분하여, 시스템의 안정성과 보안성을 유지하기 위한 방법입니다. 사용자 모드에서는 제한된 기능만 수행할 수 있고, 커널 모드에서만 시스템 자원에 접근하거나 수정하는 등의 모든 기능을 수행할 수 있습니다.</li>
      <li>유저모드와 커널모드를 구분해야 하는 이유는 시스템의 안정성과 보안성을 유지하기 위해서입니다. 모든 프로세스가 커널 모드에서 동작하게 되면, 하나의 프로세스가 시스템 전체를 망가뜨릴 수 있기 때문입니다.</li>
      <li>서로 다른 시스템 콜을 구분하는 방법은 시스템 콜 번호를 사용하는 것입니다. 각 시스템 콜은 고유한 번호를 가지고 있고, 이 번호를 통해 운영체제는 어떤 시스템 콜이 요청되었는지를 알 수 있습니다.</li>
    </ul>
</details>

<details>
  <summary><h3>2. 프로세스가 무엇인가요?</h3></summary>
  <ul>
    <li>프로세스는 운영체제에서 실행 중인 프로그램의 인스턴스를 의미합니다. 메모리에 로드되어 실행 상태를 가지며, 운영체제로부터 자원을 할당받아 동작합니다.</li>
    <li>프로그램은 디스크에 저장된 실행 코드의 정적 이미지이며, 프로세스는 프로그램이 메모리에 로드되어 실행 중인 동적 상태를 말합니다. 스레드는 프로세스 내에서 실행되는 다중 흐름의 단위로, 프로세스의 자원을 공유하면서 동시에 작업을 수행합니다.</li>
    <li>PCB(Process Control Block)는 운영체제가 각 프로세스의 정보를 관리하기 위해 사용하는 데이터 구조입니다. 프로세스의 상태, 프로그램 카운터, CPU 레지스터, 메모리 관리 정보 등을 포함합니다.</li>
    <li>스레드는 PCB를 직접 가지고 있지 않습니다. 대신 스레드는 속한 프로세스의 PCB를 공유하며, 스레드 고유의 정보는 TCB(Thread Control Block)에 저장됩니다.</li>
    <li>리눅스에서 프로세스는 fork() 시스템 콜을 이용해 생성되고, 스레드는 pthread_create() 함수를 이용해 생성됩니다.</li>
    <li>자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 '고아 프로세스'나 '좀비 프로세스'가 될 수 있습니다. 이럴 때 운영체제는 init 프로세스를 이용해 고아 프로세스를 회수하거나, wait() 또는 waitpid() 함수를 이용해 좀비 프로세스를 처리합니다.</li>
    <li>리눅스에서 데몬 프로세스는 백그라운드에서 실행되는 프로세스를 의미합니다. 사용자와 직접적인 상호작용 없이 동작하며, 서버 프로그램, 스케줄링 프로그램 등에 주로 사용됩니다.</li>
  </ul>
</details>

<details>
  <summary><h3>3. 프로세스 주소공간에 대해 설명해 주세요.</h3></summary>
  <ul>
    <li>프로세스 주소 공간은 운영체제가 프로세스를 실행하기 위해 할당하는 메모리 공간을 의미합니다. 일반적으로 코드, 데이터, 힙, 스택 영역으로 구성됩니다.</li>
    <ul>
      <li>코드 영역: 프로그램의 실행 코드가 저장됩니다.</li>
      <li>데이터 영역: 전역 변수와 정적 변수가 저장됩니다.</li>
      <li>힙 영역: 동적 할당을 통해 생성된 데이터가 저장됩니다.</li>
      <li>스택 영역: 지역 변수와 함수 호출 정보가 저장됩니다.</li>
    </ul>
    <li> 초기화되지 않은 변수들은 데이터 영역에 저장되며, 초기값은 0입니다.</li>
    <li> 스택과 힙의 크기는 프로세스가 실행되는 동안 동적으로 변경될 수 있습니다. 힙은 동적 할당에 따라 크기가 늘어나거나 줄어들며, 스택은 함수 호출과 반환에 따라 크기가 변합니다.</li>
    <li> 접근 속도는 구현 방식과 메모리 관리 전략에 따라 다르지만, 일반적으로 스택의 접근 속도가 더 빠릅니다. 이는 스택이 LIFO(Last In First Out) 방식으로 데이터를 관리하며, 항상 스택의 꼭대기에 있는 데이터만 접근하기 때문입니다.</li>
    <li> 주소 공간을 분할하는 이유는 메모리를 효율적으로 관리하고, 프로세스 간의 독립성을 유지하기 위해서입니다.</li>
    <li> 스레드의 주소 공간은 소속된 프로세스의 주소 공간을 공유합니다. 그러나 각 스레드는 자신만의 스택을 가지고 있습니다.</li>
    <li> "스택" 영역과 "힙" 영역은 각각 스택과 힙 자료구조의 동작 원리를 따릅니다. 스택 영역은 LIFO 원리에 따라 변수를 저장하고 제거하며, 힙 영역은 동적으로 할당하거나 해제하는 데이터를 저장합니다.</li>
    <li> IPC의 Shared Memory 기법은 두 프로세스 사이에 공유되는 메모리 영역을 사용합니다. 이 영역은 각 프로세스의 주소 공간에 매핑되어 있으며, 어느 한 프로세스에서 변경한 데이터를 다른 프로세스도 바로 볼 수 있습니다. 이렇게 하는 이유는 효율적인 데이터 공유와 빠른 통신 속도를 위해서입니다. </li>
  </ul>
</details>

<details>
  <summary><h3>3-1. IPC?</h3></summary>
  <ul>
    <li> IPC(Inter-Process Communication)는 서로 다른 프로세스 간에 데이터를 주고받는 기술을 의미합니다. 이를 통해 프로세스는 서로 협력하여 더 복잡한 작업을 수행할 수 있습니다. IPC의 주요 종류로는 다음과 같은 것들이 있습니다 </li>
    <ul>
      <li>파이프 (Pipe): 한 프로세스에서 다른 프로세스로 데이터를 전달하도록 설계된 통신 방법으로, 주로 부모-자식 프로세스 간에 사용됩니다.</li>
      <li>메시지 큐 (Message Queue): 프로세스 간에 데이터를 전달하는 데 사용되는 데이터 구조로, FIFO(First In First Out) 방식으로 동작합니다.</li>
      <li>공유 메모리 (Shared Memory): 두 개 이상의 프로세스가 같은 메모리 영역을 공유하여 데이터를 주고받는 방법입니다.</li>
      <li>소켓 (Socket): 네트워크를 통해 데이터를 주고받는 방법으로, 다른 기기에 있는 프로세스와도 통신이 가능합니다.</li>
      <li>시그널 (Signal): 특정 이벤트가 발생했음을 프로세스에 알리는 방법입니다.</li>
    </ul>
    <li> 공유 메모리는 두 개 이상의 프로세스가 동일한 메모리 영역을 공유하여 데이터를 주고받는 IPC 방법입니다. 이 방식은 매우 빠른 통신 속도를 제공하지만, 동시에 여러 프로세스가 메모리를 변경할 수 있으므로 동기화 문제를 주의해야 합니다. 이를 위해 세마포어나 뮤텍스 같은 동기화 기법이 필요합니다. </li>
    <li> 메시지 큐는 기본적으로 단방향 통신을 제공합니다. 즉, 메시지는 큐에 넣는 프로세스에서 가져오는 프로세스로만 이동합니다. 그러나 두 개의 메시지 큐를 사용하면 양방향 통신도 가능합니다. 이 경우 각 큐는 서로 다른 방향의 통신에 사용됩니다. </li>
  </ul>
</details>

<details>
  <summary><h3>3-2. 뮤텍스, 세마포어?</h3></summary>
  <ul>
    <li> 뮤텍스는 상호 배제(Mutual Exclusion)를 위한 도구로, 한 번에 한 스레드만 공유 자원에 접근할 수 있도록 제한합니다. 뮤텍스는 락(lock)과 언락(unlock) 두 가지 연산으로 제어되며, 동일한 스레드에서 락과 언락이 이루어져야 합니다. </li>
    <li> 세마포어(Semaphore): 세마포어는 공유 자원에 대한 동시 접근 수를 제한하는 도구로, 세마포어의 값만큼의 스레드가 동시에 접근할 수 있습니다. 세마포어는 P(Proberen, 시도하다) 연산과 V(Verhogen, 증가시키다) 연산으로 제어되며, 이 연산들은 다른 스레드에서 이루어질 수 있습니다. </li>
    <li> 이진 세마포어는 값이 0 또는 1인 세마포어로, 한 번에 한 스레드만 공유 자원에 접근할 수 있습니다. 이러한 면에서 이진 세마포어는 뮤텍스와 유사해 보일 수 있지만, 뮤텍스와는 달리 이진 세마포어의 P와 V 연산은 다른 스레드에서 이루어질 수 있습니다. 또한, 뮤텍스는 소유권 개념을 가지고 있어 락을 건 스레드만이 언락을 할 수 있지만, 이진 세마포어는 이러한 소유권 개념이 없습니다. 이러한 차이로 인해, 일반적으로 뮤텍스는 상호 배제를, 세마포어는 동기화 문제를 해결하는 데 사용됩니다. </li>
  </ul>
</details>

<details>
  <summary><h3>4. 가상 메모리란 무엇인가요?</h3></summary>
  <ul>
    <li>가상 메모리는 물리적 메모리의 크기를 초과하는 프로그램을 실행할 수 있도록 해주는 기술입니다. 이는 물리적 메모리를 디스크의 특정 부분인 스왑 영역과 함께 사용함으로써 가능하며, 프로세스마다 독립적인 주소 공간을 제공하여 메모리 보호를 가능하게 합니다.</li>
    <li> 가상 메모리가 가능한 이유는 메모리 관리 기법 중 하나인 페이징 기법 덕분입니다. 페이징 기법은 물리적 메모리를 일정한 크기의 페이지로 나누고, 가상 메모리를 같은 크기의 페이지로 나누어 물리적 메모리와 가상 메모리 사이의 매핑을 관리합니다.</li>
    <li> 페이지 폴트는 참조하려는 페이지가 물리적 메모리에 없을 때 발생합니다. 이 경우 운영체제는 다음과 같이 처리합니다. </li>
    <ul>
      <li>먼저, 필요한 페이지가 디스크에 있는지 확인합니다.</li>
      <li>페이지가 디스크에 있다면, 물리적 메모리의 빈 페이지 프레임을 찾습니다.</li>
      <li>빈 페이지 프레임에 디스크의 페이지를 로드하고, 페이지 테이블을 업데이트합니다.</li>
      <li>프로세스를 재시작합니다.</li>
    </ul>
    <li> 페이지 크기에 대한 Trade-Off는 다음과 같습니다</li>
    <ul>
      <li>페이지 크기가 크면 내부 단편화는 줄어들지만, 외부 단편화는 증가하며 페이지 폴트 시 디스크 I/O 비용이 증가합니다.</li>
      <li>페이지 크기가 작으면 내부 단편화는 증가하지만, 외부 단편화는 줄어들며 페이지 테이블의 크기가 커집니다.</li>
    </ul>
    <li> 페이지 크기가 커지면 페이지 폴트가 더 많이 발생한다고 단정할 수는 없습니다. 페이지 크기가 크면 한 페이지에 더 많은 정보가 들어가므로, 페이지 테이블의 크기는 줄어들지만, 페이지 내부에서 필요하지 않은 정보까지 메모리에 올라가기 때문에 효율성이 떨어질 수 있습니다. 따라서 실제 페이지 폴트의 발생 빈도는 프로그램의 동작 방식과 메모리 접근 패턴에 크게 의존합니다. </li>
  </ul>
</details>

<details>
  <summary><h3>5. 내부 단편화, 외부 단편화?</h3></summary>
  <ul>
    <li> 내부 단편화: 할당된 메모리 블록 내부에 사용되지 않는 공간이 발생하는 현상 </li>
    <li> 내부 단편화는 가상 메모리를 같은 크기의 블록으로 나누는 페이징 기법을 통해 해결할 수 있습니다. 페이지의 크기를 잘 선택하여 어느정도 완화가 가능합니다. </li>
    <li> 외부 단편화: 메모리의 블록 사이에 사용할 수 없는 작은 메모리 조각이 생기는 현상 </li>
    <li> 외부 단편화는 메모리 컴팩션 기법을 통해 해결할 수 있습니다. 메모리 컴팩션 기법은 사용되지 않는 메모리 블록을 하나로 합쳐 큰 메모리 블록을 만드는 방법입니다. </li>
    <li> 추가적으로, 메모리 풀 방식을 이용하면 내부 및 외부 단편화를 줄일 수 있습니다. 필요한 메모리 공간을 할당하고 반환하는 방식으로 내부 및 외부 단편화를 줄일 수 있지만, 메모리를 사용한 후에는 반드시 반환해야 합니다. 반환하지 않는다면, 메모리 누수가 발생할 수 있습니다. </li>
  </ul>
</details>

<details>
  <summary><h3>6. 세그먼트, 페이징?</h3></summary>
  <ul>
    <li> 세그멘테이션은 메모리를 가변 크기의 세그먼트로 분할하는 방식입니다. 각 세그먼트는 독립적인 주소 공간을 가지며, 파일의 일부분이나 데이터 스택 등을 나타낼 수 있습니다. 반면, 페이징은 메모리를 고정 크기의 페이지로 분할하는 방식입니다. 페이지는 물리 메모리의 프레임에 매핑되며, 가상 주소를 물리 주소로 변환하는데 사용됩니다. </li>
    <li> 페이지는 가상 메모리 시스템에서 사용하는 메모리 관리 단위로, 가상 주소 공간을 일정한 크기로 나눈 것입니다. 반면, 프레임은 물리 메모리를 페이지와 같은 크기로 나눈 메모리 블록을 의미합니다. 페이지는 이 프레임에 매핑되어 실제 메모리에 접근합니다. </li>
    <li> 페이지에서 실제 주소를 가져오는 방법: 페이지 번호와 오프셋을 결합하여 실제 메모리 주소를 얻습니다. 페이지 번호는 페이지 테이블을 통해 해당 페이지가 물리 메모리의 어느 프레임에 매핑되어 있는지를 찾습니다. 이후, 오프셋은 해당 프레임 내에서 실제 데이터의 위치를 가리킵니다. </li>
    <li> 운영체제가 각 프로세스의 메모리 보호를 관리하며, 일반적으로 코드 영역은 읽기 전용으로 설정되어 있어 수정할 수 없습니다. 반면, 데이터, 힙, 스택 영역은 수정이 가능합니다. </li>
    <li> 페이지의 크기가 1KB이고 32비트 시스템에서는 주소 공간이 4GB(2^32 바이트)이므로, 페이지 테이블의 최대 크기는 4GB / 1KB = 4,194,304(약 4백만)개입니다. </li>
    <li> Segmentation Fault는 프로세스가 자신에게 할당되지 않은 메모리 영역에 접근하려고 할 때 발생하는 오류입니다. 이는 세그멘테이션과 페이징 시스템에서 각 프로세스의 독립적인 주소 공간을 보호하는 운영체제의 역할과 관련이 있습니다. 이 오류가 발생하면, 대개는 포인터 오류나 배열 경계를 벗어나는 접근 등이 원인입니다. </li>
  </ul>
</details>

<details>
  <summary><h3>7. File Descriptor, File System?</h3></summary>
  <ul>
    <li> 파일 디스크립터는 운영체제에서 파일이나 소켓 등의 입출력 리소스를 추상화한 것입니다. 프로세스가 파일을 열면 운영체제는 해당 파일에 대한 정보를 유지하며, 이 정보에 접근할 수 있는 정수 값을 프로세스에게 반환합니다. 이 값이 바로 파일 디스크립터입니다. 프로세스는 이 파일 디스크립터를 사용하여 파일을 읽거나 쓰거나, 파일 위치를 변경하는 등의 작업을 수행할 수 있습니다. </li>
    <li> 파일 시스템은 운영체제가 데이터를 저장하는 방법을 정의하는데, 이는 디스크 드라이브나 SSD, USB 메모리 등의 저장 매체에 파일을 저장하고 검색하는 방법을 제공합니다. 파일 시스템은 파일과 디렉토리의 계층적 구조를 관리하고, 메타데이터(파일 이름, 크기, 생성 날짜, 접근 권한 등)를 유지하며, 빈 공간을 추적하고 오류를 검사하고 복구하는 등의 역할을 합니다. </li>
    <li> I-Node: 인덱스 노드(Index Node)의 줄임말로, Unix 계열의 파일 시스템에서 파일의 메타데이터를 저장하는 데이터 구조입니다. I-Node는 파일의 소유자, 접근 권한, 파일 타입, 파일 크기, 수정 시간 등의 정보를 포함하며, 파일 데이터가 저장된 디스크의 블록 위치를 가리키는 포인터도 가지고 있습니다. 파일 시스템은 파일 이름과 I-Node 번호 사이의 매핑을 디렉토리에서 유지하여, 파일 이름으로 파일에 접근할 수 있게 합니다. </li>
  </ul>
</details>

<details>
  <summary><h3>8. SSD, HDD</h3></summary>
  <ul>
    <li> SSD는 반도체 메모리를 사용하여 데이터를 저장하는 저장 장치입니다. SSD는 전원이 꺼져도 데이터를 저장할 수 있는 플래시 메모리를 사용하며, 이 때문에 SSD는 HDD보다 더 빠른 데이터 액세스 속도를 제공합니다. 또한, SSD는 움직이는 부품이 없어서 HDD에 비해 내구성이 뛰어나고, 소음이 적으며, 소비 전력도 적습니다. 하지만, SSD의 단점은 비용이 비교적 높고, 쓰기 작업의 횟수에 한계가 있다는 것입니다. </li>
    <li> HDD는 원판 모양의 플래터에 자기를 이용해 데이터를 읽고 쓰는 방식의 저장 장치입니다. HDD는 SSD에 비해 데이터 액세스 속도가 느리지만, 대용량의 데이터를 비교적 저렴한 비용으로 저장할 수 있다는 장점이 있습니다. 또한, 쓰기 작업의 횟수에 제한이 없습니다. 하지만, HDD는 움직이는 부품이 있어서 충격에 약하고, 소음이 발생하며, 전력 소비가 많습니다. </li>
  </ul>
</details>
